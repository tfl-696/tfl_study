1. 当我们输入网址并回车后，浏览器开始解析URL
   
   - 关于URL的知识点
     
     - <u>http</u>（数据传输协议）://Web服务器域名（目标设备的名字）<u>/目录名/文件名</u>（被访问的文件所在的路径，这个路径可有可无，没有这个路径，那么就是访问默认文件）
     
     - URL的作用就是获取服务器里指定的文件资源 

2. 浏览器解析完成，确定了Web服务器的域名和目标文件，接下来就是根据确定的信息生成HTTP请求。
   
   - 请求格式
     
     <img src="file:///C:/Users/唐飞龙/AppData/Roaming/marktext/images/2023-10-12-10-34-12-image.png" title="" alt="" width="478">
   
   - 响应格式 
     
     <img src="file:///C:/Users/唐飞龙/AppData/Roaming/marktext/images/2023-10-12-10-35-10-image.png" title="" alt="" width="477">

3. 生成HTTP消息后，委托操作系统将消息发送给 `Web` 服务器，但是在这个操作之前还需要查询服务器域名对应的IP地址，因为委托操作系统发送消息必须提供通信对象的 IP 地址。
   
   DNS服务器专门用于保存服务器域名与 IP地址的映射。
   
   - **域名的层级关系**：
     
     - 域名用**句点**来分隔的，比如 `www.server.com`，句点代表了不同层级之间的**界限**。在域名中，**越靠右**的位置表示其层级**越高**。
     
     - Web服务器域名（完整的域名：www.server.com.）需要多种类型的DNS服务器分层级解析。DNS服务器的类型有：
       
       - 根域名DNS服务器（.）
       - 顶级域 DNS 服务器（.com）
       - 权威 DNS 服务器（server.com）
       
       <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" title="" alt="DNS 树状结构" width="308">
       
       - 根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器，因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到目标 DNS 服务器，获取域名对应的IP地址。
   
   - **域名解析的工作流程**：
     
     1. 客户端首先会给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）发出一个 DNS 请求，询问 `www.server.com`对应的 IP地址 是啥。
     
     2. 本地域名服务器收到客户端的请求后，查询缓存，看是否有`www.server.com`对应的IP地址，有就直接返回 IP 地址。没有的话，本地 DNS服务器就会给根域名服务器发送请求，询问  `www.server.com`对应的IP地址是啥。
     
     3. 根域名服务器收到请求后，发现`www.server.com`的顶级域名是com，就会查询内部存放的com对应的顶级域名服务器的IP地址，并将该IP地址返回给本地DNS服务器。
     
     4. 本地域名服务器收到顶级域名服务器的IP地址后，给根域名服务器发送请求，询问 `www.server.com`对应的IP地址是啥。
     
     5. 顶级域名服务器收到请求后，发现`www.server.com`的权威域名是server.com，就会查询内部存放的server.com对应的权威域名服务器的IP地址，并将该IP地址返回给本地DNS服务器。
     
     6. 本地域名服务器收到权威域名服务器的IP地址后，给权威域名服务器发送请求，询问 `www.server.com`对应的IP地址是啥。权威域名服务器是域名解析结果的出处。
     
     7. 权威域名服务器收到请求后，查询内部存放的www.server.com对应的IP地址，并将该IP地址返回给本地DNS服务器。
     
     8. 本地域名服务器收到 IP 地址后先缓存再返回客户端。
        
        <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" title="" alt="域名解析的工作流程" width="399">
        
        是不是每次解析域名都要经过那么多的步骤呢？
        
        当然不是了，还有缓存这个东西的嘛。浏览器会先查看自己的缓存中有没有这个域名对应的IP地址，如果有，就直接返回，如果没有，就去问操作系统，操作系统看自己的缓存中有没有，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。

4. 通过域名服务器获取Web服务器域名对应的IP地址后，就可以通过调用socket库来委托操作系统中的**协议栈**工作。
   
   <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" title="" alt="" width="327">
   
   - 协议栈上半部分的两块是负责收发数据的TCP和UDP协议，这两个传输协议接受应用层委托，执行收发数据操作。
   
   - 协议栈下半部分采用IP协议控制网络包收发操作。
   
   - 网络层中还包括 `ICMP` 协议和 `ARP` 协议：
     
     - `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
     
     - `ARP` 用于根据 IP 地址查询相应的MAC 地址。
   
   - 网络层下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

5. **可靠传输TCP**
   
   HTTP应用层数据是基于TCP协议传输的。
   
   TCP协议基础知识：
   
   - TCP首部格式
     
     <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg" title="" alt="TCP 包头格式" width="333">
     
     **源端口号**和**目标端口**号必不可少的，用来确定收发数据的应用。
     
     **序号**，用来解决TCP数据包顺序混乱的问题。
     
     **确认号**，用来确认对方是否收到某个发出去的数据包。如果没有收到就重新发送，直到对方收到，就是为了解决丢包的问题。
     
     一些**状态位**，例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，需要双方维护<u>连接</u>（这个所谓的「连接」，只是双方计算机里的一个状态机）的状态，这些带状态位的包的发送，会引起双方状态的变更。
     
     **窗口大小**，用于TCP 进行**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前处理能力，别发送的太快，撑死我，也别发的太慢，饿死我，还会用于TCP进行**拥塞控制**，控制自己发送数据包的速度。
   
   - TCP 传输数据之前，要先三次握手建立连接：
     
     在连接建立的过程中，双方的状态机变化时序图就像这样
     
     <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" title="" alt="TCP 三次握手" width="419">
     
     - 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
     
     - 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
     
     - 服务端收到发起的连接，<u>返回 `SYN`</u>(向客户端发起一个连接)，并且<u> `ACK` 客户端的 `SYN`</u>（确认和客户端建立连接），之后处于 `SYN-RCVD` 状态。
     
     - 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，<u>发送对 `SYN` 确认的 `ACK`</u>，（确认和服务器端建立连接），之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
     
     - 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。
     
     三次握手目的是**保证双方都有发送和接收的能力**。
   
   - TCP 分割数据
   
   - 客户端通常在开发或配置阶段就确定了源端口和目的端口号是多少。

6. IP
   
   TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。
   
   - IP首部的格式
   
   <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg" title="" alt="IP 包头格式" width="317">

在 IP 协议里面需要有**源地址 IP** 和 **目标地址 IP**：

- 源地址IP：客户端的 IP 地址；
- 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

因为 HTTP 是经过 TCP 传输的，所以在 IP 首部的**协议号**，要填写为 `06`（十六进制），表示协议为 TCP。

> 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个IP？

答：当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。

举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 `192.168.10.200`。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg" title="" alt="路由规则判断" width="440">

1. 首先先和第一条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 IP 地址作为 IP 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。所以将使用 `eth0` 网卡的 IP 地址作为 IP 包头的源地址，并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。

7.MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。

> MAC数据包首部格式

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg" title="" alt="MAC 包头格式" width="337">    

在 MAC首部里面需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

> 知道了要发给谁（知道了对方的IP地址），那么该如何获取对方的 MAC 地址呢？

不知道对方 MAC 地址？不知道就喊呗。

此时就需要 `ARP` 协议帮我们找到路由器的 MAC 地址。

![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg)

ARP 协议会在以太网中以**广播**的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

> 好像每次都要广播获取，这不是很麻烦吗？

放心，后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

> MAC 报文生成

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" title="" alt="MAC 层报文" width="257">

8. 数据出口-网卡
   
   网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。
   
   负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**。
   
   网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。
   
   ![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)
   
   - 起始帧分界符是一个用来表示包起始位置的标记
   - 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有
   
   最后网卡会将包转为电信号，通过网线发送出去。

9. 送别者 —— 交换机

交换机的功能是将数据包转发到目的地

> 交换机的包接收操作

首先，电信号到达网线接口，由交换机里的模块进行接收并将电信号转换为数字信号。然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。和网卡不同，**交换机的端口不具有 MAC 地址**，因此交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中，而计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。交换机的 MAC 地址表主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是该设备连接在交换机的哪个端口上。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg" title="" alt="交换机的 MAC 地址表" width="451">

举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。

> 当 MAC 地址表找不到指定的 MAC 地址会怎么样？

原因分析：

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

解决方案：

这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。

提出问题1：这样做会不会有啥问题？

这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。

提出问题2：有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”

其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

此外，如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`
11. 出境大门 —— 路由器
    
    > 路由器和交换机的区别
    
    数据包到达路由器后，会被路由器转发到下一个路由器或设备。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的：
    
    - **路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。
    
    > 路由器基本原理
    
    路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。
    
    当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询下一个转发目标，再由相应的端口作为发送方将以太网包发送出去。
    
    > 路由器的包接收操作
    
    首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃.
    
    > 查询路由表确定输出端口
    
    完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。
    
    
    转发操作分为几个阶段，首先是查询**路由表**判断转发目标。
    
    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" title="" alt="路由器转发" width="444">
    
    具体的工作流程根据上图，举个例子。
    
    假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。
    
    判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。
    
    路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` IP 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。
    
    如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` IP 做 **& 与运算**后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。
    
    实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。
    
    **路由器的发送操作**
    
    首先，我们需要根据**路由表的网关列**判断对方的地址。
    
    - 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
    - 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。
    - 网关的主要作用是在不同网络之间传递数据包，执行协议转换和路由功能，以确保数据可以从一个网络传输到另一个网络。
    
    知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。
    
    路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。
    
    接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。
    
    网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。
    
    发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。
    
    在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

互相拆解数据包 —— 服务器 与 客户端

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" title="" alt="网络分层模型" width="386">

数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。





我一开始我虽然孤单、不知所措，但没有停滞不前。我依然满怀信心和勇气开始了征途。（**你当然有勇气，你是应用层数据，后面有底层兄弟当靠山，我呸！**）

我很庆幸遇到了各路神通广大的大佬，有可靠传输的 TCP、有远程定位功能的 IP、有指明下一站位置的 MAC 等（**你当然会遇到，因为都被计算机安排好的，我呸！**）。

这些大佬都给我前面加上了头部，使得我能在交换机和路由器的转发下，抵达到了目的地！（**哎，你也不容易，不吐槽了，放过你！**）

这一路上的经历，让我认识到了网络世界中各路大侠协作的重要性，是他们维护了网络世界的秩序，感谢他们！（**我呸，你应该感谢众多计算机科学家！**）
