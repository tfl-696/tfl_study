# 操作系统

---

## 1. 小林coding：如何避免死锁 ?

### 1.1 死锁的概念

多个进程/线程都在等待对方释放锁，在没有外力介入的情况下，这些进程/线程会一直相互等待，没办法执行下去，这种情况就是死锁。

### 1.2 死锁发生的条件

#### 1. 互斥条件

- 多个进程/线程不能同时使用同一个资源。

#### 2.  持有并等待条件

- 某个进程/线程阻塞等待某个资源的同时，还持有另外一个资源。

#### 3. 不可剥夺条件

- 线程持有的资源在自己用完之前是不能被其他线程获取的。

#### 4. 环路等待条件

- 多个线程获取资源的顺序构成了环形链。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.png)

### 1.3 模拟死锁问题的产生

```cpp
- 创建 2 个线程，分别为线程 A 和 线程 B
- 然后有两个互斥锁，分别是 mutex_A 和 mutex_B

pthread_mutex_t mutex_A = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex_B = PTHREAD_MUTEX_INITIALIZER;

int main()
{
    pthread_t tidA, tidB;

    //创建两个线程
    pthread_create(&tidA, NULL, threadA_proc, NULL);
    pthread_create(&tidB, NULL, threadB_proc, NULL);

    pthread_join(tidA, NULL);
    pthread_join(tidB, NULL);

    printf("exit\n");

    return 0;
}
```

```cpp
//线程 A 函数
void *threadA_proc(void *data)
{
    printf("thread A waiting get ResourceA \n");
    pthread_mutex_lock(&mutex_A);
    printf("thread A got ResourceA \n");

    sleep(1);

    printf("thread A waiting get ResourceB \n");
    pthread_mutex_lock(&mutex_B);
    printf("thread A got ResourceB \n");

    pthread_mutex_unlock(&mutex_B);
    pthread_mutex_unlock(&mutex_A);
    return (void *)0;
}

- 线程 A 函数的过程：
  1. 先获取互斥锁 A，然后睡眠 1 秒；
  2. 再获取互斥锁 B，然后释放互斥锁 B；
  3. 最后释放互斥锁 A；
```

```cpp
//线程B函数
void *threadB_proc(void *data)
{
    printf("thread B waiting get ResourceB \n");
    pthread_mutex_lock(&mutex_B);
    printf("thread B got ResourceB \n");

    sleep(1);

    printf("thread B waiting  get ResourceA \n");
    pthread_mutex_lock(&mutex_A);
    printf("thread B got ResourceA \n");

    pthread_mutex_unlock(&mutex_A);
    pthread_mutex_unlock(&mutex_B);
    return (void *)0;
}

- 线程 B 函数的过程：
  1. 先获取互斥锁 B，然后睡眠 1 秒；
  2. 再获取互斥锁 A，然后释放互斥锁 A；
  3. 最后释放互斥锁 B；
```

运行这个程序，运行结果如下:

thread B waiting get ResourceB 
thread B got ResourceB 
thread A waiting get ResourceA 
thread A got ResourceA 
thread B waiting get ResourceA 
thread A waiting get ResourceB 
// 阻塞中... 

线程 B 在等待互斥锁 A 的释放，线程 A 在等待互斥锁 B 的释放，双方都在等待对方资源
的释放，很明显，产生了死锁问题。

### 1.4 避免死锁问题的产生

办法：破坏产生死锁的条件中的任何一个条件即可，最常见的并且可行的就是**使用资源有序分配法，来<font color="red">破坏环路等待条件</font>。**

#### 1.4.1  什么是资源有序分配法？

线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/%E8%B5%84%E6%BA%90%E6%9C%89%E5%BA%8F%E5%88%86%E9%85%8D.png)

#### 1.4.2  修改1.3代码消除死锁

```cpp
- 修改后：
//线程 B 函数访问资源的顺序，同线程 A 一样，先获取互斥锁 A，然后获取互斥锁 B
void *threadB_proc(void *data)
{
    printf("thread B waiting get ResourceA \n");
    pthread_mutex_lock(&mutex_A);
    printf("thread B got ResourceA \n");

    sleep(1);

    printf("thread B waiting  get ResourceB \n");
    pthread_mutex_lock(&mutex_B);
    printf("thread B got ResourceB \n");

    pthread_mutex_unlock(&mutex_B);
    pthread_mutex_unlock(&mutex_A);
    return (void *)0;
}

- 线程 B 函数的过程：
  1. 先获取互斥锁 A，然后睡眠 1 秒；
  2. 再获取互斥锁 B，然后释放互斥锁 B；
  3. 最后释放互斥锁 A；
```

```cpp
修改前：
//线程B函数
void *threadB_proc(void *data)
{
 printf("thread B waiting get ResourceB \n");
 pthread_mutex_lock(&mutex_B);
 printf("thread B got ResourceB \n");

sleep(1);

printf("thread B waiting get ResourceA \n");
 pthread_mutex_lock(&mutex_A);
 printf("thread B got ResourceA \n");

pthread_mutex_unlock(&mutex_A);
 pthread_mutex_unlock(&mutex_B);
 return (void *)0;
}

- 线程 B 函数的过程：

  1. 先获取互斥锁 B，然后睡眠 1 秒；
  2. 再获取互斥锁 A，然后释放互斥锁 A；
  3. 最后释放互斥锁 B；
```

--- 

# 2. 锁的选择与使用

## 2.1.  互斥锁与自旋锁

### 2.1.1. 基础概念

互斥锁和自旋锁是**最底层的锁**，是其他高级锁的基础。

互斥锁和自旋锁的目的是**保证共享资源**在任何时候都**只能被一个进/线程访问**，避免共享数据因为多进/线程的竞争而错乱。

### 2.1.2. 加锁失败的处理方式

当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的。

#### 2.1.2.1. 互斥锁的处理方式

获取锁失败的线程会释放 CPU ，给其他线程使用。(线程切换)

<img title="" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/%E4%BA%92%E6%96%A5%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="" width="414" data-align="left">

互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本，即会有**两次线程上下文切换的成本**：

- 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
- 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

线程的上下文切换的是什么？切换的是线程的私有数据、寄存器等不共享数据。

上下切换的耗时大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。所以，**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**

#### 2.1.2.2. 自旋锁的处理方式

线程会忙等待，直到它拿到锁。忙等待可以用 `while` 循环实现，不过最好是使用 CPU 提供的 `PAUSE` 指令来实现忙等待，可以减少循环等待时的耗电量。

自旋锁是通过 CPU 提供的 `CAS` 函数（*Compare And Swap*），在用户态完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。

一般加锁的过程，包含两个步骤：第一步，查看锁的状态，如果锁是空闲的，则执行第二步；第二步，将锁设置为当前线程持有。CAS 函数就把这两个步骤合并成一条硬件级指令，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。比如，设锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0) 则表示解锁操作。

**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。**

自旋锁开销少，在**多核系统下**一般**不会主动进行线程切换**，适合异步、协程等在用户态切换请求的编程方式，但如果某个线程在临界区内执行的时间过长，那么自旋的线程会长时间占用 CPU 资源，所以自旋的时间和线程在临界区执行的时间是成「正比」关系，我们需要清楚的知道这一点。



## 2.2.  读写锁

## 2.3.  乐观锁与悲观锁
