# C++八股文

## C++内存分布情况

1. 栈：由编译器进行分配和回收，存放函数的参数，局部变量等

2. 堆：通过new，delete，malloc，free动态分配和回收内存，但是可能会存在内存泄漏和内存碎片

3. 全局区：分为初始化和未初始化两个相邻的区域，存储初始化和未初始化的全局变量和静态变量

4. 常量区：存放常量，只读

5. 代码区：存放程序的二进制代码

## 栈和堆的区别

栈

- 由编译器管理，根据需要自动分配和回收，用于存放函数参数，局部变量等，

- 是连续的存储空间。

堆

- 由程序员自己管理，在需要时通过new或malloc申请分配空间，在不需要的时候通过delete或free回收空间。如果不回收释放，则存在内存泄漏的问题。

- 不连续的存储空间

- 系统中存有一个空闲内存链表，当申请分配内存时，系统会遍历空闲链表，找到第一个内存空间大于或等于申请的空间用于分配，在分配内存时，会在内存头部写入内存的大小，目的是方便delete回收。
  
  <img src="https://cdn.xiaolincoding.com//mysql/other/cb6e3ce4532ff0a6bfd60fe3e52a806e.png" title="" alt="图片" width="251">

## new和malloc的区别

- new和delete是C++关键字，malloc和free是C语言库函数，它们都用于动态申请内存和释放内存。new的底层实现是基于malloc的。

- new在获得分配的内存后会自动调用构造函数初始化内存中的数据，delete会先自动调用析构函数来释放占用的资源，然后再释放内存；malloc只分配内存，free只释放内存。

- 使用new申请内存时不需要计算请求内存的大小并且不需要对返回类型进行强制类型转换，因为返回类型就是申请类型；malloc相反，既需要手动计算请求内存的大小，还需要通过强制类型转换对返回类型将转换为需要的类型，因为malloc返回的类型为void*。

- new申请内存失败时引发异常；malloc申请内存失败会返回NULL。

## 为什么有了malloc/free后还需要new/delete

- `new` 和 `delete` 能够在对象被创建时自动调用构造函数初始化对象，在对象不再被需要时，自动调用析构函数来清理对象占用的资源，而malloc` 和 `free` 则不能自动完成，需要手动完成，但是手动可能会引发错误。

- `new` 和 `delete` 能够重载来自定义内存分配和释放时要进行的操作。

## 函数传递参数的几种方式

- 值传递：形参是实参的拷贝，形参的改变并不影响实参。

- 指针传递：形参接收实参的地址，对形参的任何操作等价于对实参的操作。

- 引用传递：对形参的操作可以直接映射到实参上

## C++中指针参数的传递和引用参数的传递

- 指针参数传递：本质是值传递，即传递的值是地址值，函数的形参被作为函数中的局部变量处理，即实参值的拷贝值，即形参的值，会被存放在栈中。当形参的值是实参值的拷贝值时，对形参的操作就是对实参的操作，若形参值发生了变化，则无法操作实参。

- 引用参数传递：函数的形参也是作为函数的局部变量，会在栈区申请内存空间，但存放的是实参变量的地址，故而对形参的任何操作都会直接影响到实参，即可以通过栈中的地址找到实参变量。

- 两者的不同：虽然它们都是存放在栈空间上的局部变量，但是引用参数的值在函数内部不可更改，而指针参数的值在函数内部可更改。

## 指针和引用的区别
