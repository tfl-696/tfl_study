# C++八股文

## C++内存分布情况

1. 栈：由编译器进行分配和回收，存放函数的参数，局部变量等

2. 堆：通过new，delete，malloc，free动态分配和回收内存，但是可能会存在内存泄漏和内存碎片

3. 全局区：分为初始化和未初始化两个相邻的区域，存储初始化和未初始化的全局变量和静态变量

4. 常量区：存放常量，只读

5. 代码区：存放程序的二进制代码

## 栈和堆的区别

栈

- 由编译器管理，根据需要自动分配和回收，用于存放函数参数，局部变量等，

- 是连续的存储空间。

堆

- 由程序员自己管理，在需要时通过new或malloc申请分配空间，在不需要的时候通过delete或free回收空间。如果不回收释放，则存在内存泄漏的问题。

- 不连续的存储空间

- 系统中存有一个空闲内存链表，当申请分配内存时，系统会遍历空闲链表，找到第一个内存空间大于或等于申请的空间用于分配，在分配内存时，会在内存头部写入内存的大小，目的是方便delete回收。
  
  <img src="https://cdn.xiaolincoding.com//mysql/other/cb6e3ce4532ff0a6bfd60fe3e52a806e.png" title="" alt="图片" width="251">

## new和malloc的区别

- new和delete是C++关键字，malloc和free是C语言库函数，它们都用于动态申请内存和释放内存。new的底层实现是基于malloc的。

- new在获得分配的内存后会自动调用构造函数初始化内存中的数据，delete会先自动调用析构函数来释放占用的资源，然后再释放内存；malloc只分配内存，free只释放内存。

- 使用new申请内存时不需要计算请求内存的大小并且不需要对返回类型进行强制类型转换，因为返回类型就是申请类型；malloc相反，既需要手动计算请求内存的大小，还需要通过强制类型转换对返回类型将转换为需要的类型，因为malloc返回的类型为void*。

- new申请内存失败时引发异常；malloc申请内存失败会返回NULL。

## 为什么有了malloc/free后还需要new/delete

- `new` 和 `delete` 能够在对象被创建时自动调用构造函数初始化对象，在对象不再被需要时，自动调用析构函数来清理对象占用的资源，而malloc` 和 `free` 则不能自动完成，需要手动完成，但是手动可能会引发错误。

- `new` 和 `delete` 能够重载来自定义内存分配和释放时要进行的操作。

## 函数传递参数的几种方式

- 值传递：形参是实参的拷贝，形参的改变并不影响实参。

- 指针传递：形参接收实参的地址，对形参的任何操作等价于对实参的操作。

- 引用传递：对形参的操作可以直接映射到实参上

## C++中指针参数的传递和引用参数的传递

- 指针参数传递：本质是值传递，即传递的值是地址值，函数的形参被作为函数中的局部变量处理，即实参值的拷贝值，即形参的值，会被存放在栈中。当形参的值是实参值的拷贝值时，对形参的操作就是对实参的操作，若形参值发生了变化，则无法操作实参。

- 引用参数传递：函数的形参也是作为函数的局部变量，会在栈区申请内存空间，但存放的是实参变量的地址，故而对形参的任何操作都会直接影响到实参，即可以通过栈中的地址找到实参变量。

- 两者的不同：虽然它们都是存放在栈空间上的局部变量，但是引用参数的值在函数内部不可更改，而指针参数的值在函数内部可更改。

## 指针和引用的区别

## 静态链接和动态链接

静态链接是指将二进制目标文件链接（组合）成一个可执行文件

动态链接是指在程序运行时将需要的部分与自身进行链接（组合）

**为什么需要链接？**

因为一个源文件可能会使用到其他源文件里面的内容，但是每个源文件又都是独立的，为了让源文件能够使用到其他源文件中它需要的内容，就需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

<img src="https://img-blog.csdn.net/20180505235327609" title="" alt="" width="327">

根据源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a（标准库）中找到目标文件printf.o，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。

**静态链接的优缺点：**

缺点有：一、浪费空间，每个可执行程序中都有一份所需要的目标文件副本，如果多个程序对同一个目标文件都有依赖，例如：多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件在内存中存在多个副本；二、更新比较困难，每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

优点就是可执行程序已经具备了执行所需要的任何东西，在执行的时候运行速度快。

**为什么要有动态链接？**
动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。

动态链接原理：

动态链接的基本思想是把程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

**动态链接过程：**

假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

**动态链接的优缺点**

优点是即使每个程序都需要依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时**共享同一份副本**；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

据估算，动态链接和静态链接相比，性能损失大约在5%以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。

**动态链接地址是如何重定位的呢？**

前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。

---

**头文件的多重包含问题**

- 多重包含会让编译器做重复计算，降低一些性能，不会有实质上编译错误。

- 多重包含会出现在两种情景：
  
  1. 一个h文件被一个cpp文件多次包含
     
     编译后，a.c中进行了两次`#include "b.h"`，这就使得`int t = 0;`重复定义了，而且b.h里的大量声明也重复了两次。  
     这时候有人会发现，如果对头文件进行**防重复包含处理**（#prama once），`int t = 0;` 就不会重复定义了。
  
  2. 一个h文件被多个c文件包含
     
     编译后，**`a.c`** 和 **`b.c`** 都定义了 **`int t = 0;`**，编译阶段c/cpp文件是单独编译，所以不会发生头文件多重包含的问题，但在链接阶段，会发生重复定义t变量的问题，因为编译器在编译.c或.cpp文件时，有个很重要的步骤，就是给这些文件中的已经定义了的变量生成分配信息， t变量只能有唯一的分配信息，但是b.c和a.c中的t变量对应不同的分配信息，那么运行时就会导致同一个变量被分配的内存的内存地址不同，程序运行期间无法判断哪个才是t变量的地址， 就会产生二义性导致程序出错。

- 解决办法：
  
  **头文件尽量只有声明，不要有定义**。这么做不仅仅可以减少编译带来的时间性能消耗，还可以防止重复定义现象的发生，防止程序崩溃。

---

**从源代码到可执行文件的主要步骤：**

1. **预处理**：源代码通过预处理器处理预处理指令，例如`#include`、`#define`等，展开宏，去除注释等。生成一个经过预处理的中间文件。

2. **编译**：将预处理后生成的文件编译成汇编语言文件，并检查代码的语法和语义。这个汇编代码仍然是平台无关的中间代码。

3. **汇编**：汇编代码被汇编器转化为机器码（二进制代码），生成目标文件。每个源文件都生成一个对应的目标文件。

4. **链接**：链接阶段将所有目标文件及其所需库文件组合在一起，生成可执行文件，其中库（如标准库或自定义库）文件是通过解析外部引用操作导入进来的。链接器生成可执行文件，并将所有目标文件中的代码组合到一个单独的文件中。

5. **加载**（可选）：在某些情况下，可执行文件可能需要被加载到内存中才能运行。这是操作系统的任务，它会将可执行文件加载到内存中，并启动程序的执行。

6. **执行**：一旦加载到内存中，操作系统会启动程序的执行，执行程序中的主函数或入口点，这标志着程序的运行开始。

![](https://img-blog.csdnimg.cn/c441806a9aa6484591bbbeda9cb5adb7.png)

编译器会为定义好的全局变量生成分配信息，分配信息包括但不限于数据类型，虚拟内存地址，虚拟内存大小。

全局变量如果是定义时赋值那么全局变量会在数据段中分配内存，如果没有赋值则会在bss段中分配内存。
